
orgel_SW_402.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00803f00  00803f00  000007ec  2**0
                  ALLOC, LOAD, DATA
  1 .text         0000008a  00000000  00000000  00000114  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      0000002f  00000000  00000000  000007ec  2**0
                  CONTENTS, READONLY
  3 .stack.descriptors.hdr 00000038  00000000  00000000  0000081b  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000f0  00000000  00000000  00000858  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003066  00000000  00000000  00000948  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000144b  00000000  00000000  000039ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a0b  00000000  00000000  00004df9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000214  00000000  00000000  00005804  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000081e  00000000  00000000  00005a18  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000004bd  00000000  00000000  00006236  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  000066f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000002  000006ce  000006ce  000007e2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000067b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text.wait_1us 00000004  000006c6  000006c6  000007da  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.spi_trans 00000064  0000047a  0000047a  0000058e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.spi_reset 00000008  000006b6  000006b6  000007ca  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.W25_PWR_DOWN 0000001a  00000626  00000626  0000073a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.VOICES_SEL 000000a8  00000134  00000134  00000248  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.put_buf 0000002e  00000510  00000510  00000624  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.sw_read 0000009e  0000027c  0000027c  00000390  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.apl_init 00000010  00000670  00000670  00000784  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.CB_VOICES_END 00000008  000006be  000006be  000007d2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.voiceS_exe 0000007e  0000031a  0000031a  0000042e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.wait_us 0000002a  0000053e  0000053e  00000652  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.wait_ms 0000001c  000005ee  000005ee  00000702  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.W25_PWR_UP 00000018  00000640  00000640  00000754  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.__vector_8 00000070  0000040a  0000040a  0000051e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.pwm_wait 00000010  00000680  00000680  00000794  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.CB_INIT 000000a0  000001dc  000001dc  000002f0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.dev_pwm_stop 00000026  00000568  00000568  0000067c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.dev_pwm_start 00000024  0000058e  0000058e  000006a2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.apl_sleep 00000032  000004de  000004de  000005f2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.CB_KOYUU 00000072  00000398  00000398  000004ac  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.main    000000aa  0000008a  0000008a  0000019e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.__vector_7 0000001e  000005b2  000005b2  000006c6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.__vector_3 0000001e  000005d0  000005d0  000006e4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .bss.sleep_tmr.3121 00000002  00803f3a  00803f3a  000007ec  2**0
                  ALLOC
 38 .bss.onseiS   00000001  00803f3c  00803f3c  000007ec  2**0
                  ALLOC
 39 .bss.sw_hst   00000001  00803f3d  00803f3d  000007ec  2**0
                  ALLOC
 40 .rodata.sw_cnf 00000004  008086ca  000006ca  000007de  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 41 .bss.buf_read 00000001  00803f3e  00803f3e  000007ec  2**0
                  ALLOC
 42 .bss.buf_write 00000001  00803f3f  00803f3f  000007ec  2**0
                  ALLOC
 43 .bss.buf      00000028  00803f00  00803f00  000007ec  2**0
                  ALLOC
 44 .bss.voiceS   0000000e  00803f28  00803f28  000007ec  2**0
                  ALLOC
 45 .bss.kyotuu   00000004  00803f36  00803f36  000007ec  2**0
                  ALLOC
 46 .rodata.voiceS_idx 0000001b  0080860a  0000060a  0000071e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 47 .text.libgcc.mul 0000000c  0000069e  0000069e  000007b2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.libgcc.mul 00000018  00000658  00000658  0000076c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.__dummy_fini 00000002  000006d0  000006d0  000007e4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.__dummy_funcs_on_exit 00000002  000006d2  000006d2  000007e6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.__dummy_simulator_exit 00000002  000006d4  000006d4  000007e8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.exit    0000000e  00000690  00000690  000007a4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text._Exit   00000002  000006d6  000006d6  000007ea  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .text.avrlibc 0000000c  000006aa  000006aa  000007be  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	1c c0       	rjmp	.+56     	; 0x3a <__ctors_end>
   2:	65 c3       	rjmp	.+1738   	; 0x6ce <__bad_interrupt>
   4:	64 c3       	rjmp	.+1736   	; 0x6ce <__bad_interrupt>
   6:	e4 c2       	rjmp	.+1480   	; 0x5d0 <__vector_3>
   8:	62 c3       	rjmp	.+1732   	; 0x6ce <__bad_interrupt>
   a:	61 c3       	rjmp	.+1730   	; 0x6ce <__bad_interrupt>
   c:	60 c3       	rjmp	.+1728   	; 0x6ce <__bad_interrupt>
   e:	d1 c2       	rjmp	.+1442   	; 0x5b2 <__vector_7>
  10:	fc c1       	rjmp	.+1016   	; 0x40a <__vector_8>
  12:	5d c3       	rjmp	.+1722   	; 0x6ce <__bad_interrupt>
  14:	5c c3       	rjmp	.+1720   	; 0x6ce <__bad_interrupt>
  16:	5b c3       	rjmp	.+1718   	; 0x6ce <__bad_interrupt>
  18:	5a c3       	rjmp	.+1716   	; 0x6ce <__bad_interrupt>
  1a:	59 c3       	rjmp	.+1714   	; 0x6ce <__bad_interrupt>
  1c:	58 c3       	rjmp	.+1712   	; 0x6ce <__bad_interrupt>
  1e:	57 c3       	rjmp	.+1710   	; 0x6ce <__bad_interrupt>
  20:	56 c3       	rjmp	.+1708   	; 0x6ce <__bad_interrupt>
  22:	55 c3       	rjmp	.+1706   	; 0x6ce <__bad_interrupt>
  24:	54 c3       	rjmp	.+1704   	; 0x6ce <__bad_interrupt>
  26:	53 c3       	rjmp	.+1702   	; 0x6ce <__bad_interrupt>
  28:	52 c3       	rjmp	.+1700   	; 0x6ce <__bad_interrupt>
  2a:	51 c3       	rjmp	.+1698   	; 0x6ce <__bad_interrupt>
  2c:	50 c3       	rjmp	.+1696   	; 0x6ce <__bad_interrupt>
  2e:	4f c3       	rjmp	.+1694   	; 0x6ce <__bad_interrupt>
  30:	4e c3       	rjmp	.+1692   	; 0x6ce <__bad_interrupt>
  32:	4d c3       	rjmp	.+1690   	; 0x6ce <__bad_interrupt>

00000034 <.dinit>:
  34:	3f 00       	.word	0x003f	; ????
  36:	3f 40       	sbci	r19, 0x0F	; 15
  38:	80 00       	.word	0x0080	; ????

0000003a <__ctors_end>:
  3a:	11 24       	eor	r1, r1
  3c:	1f be       	out	0x3f, r1	; 63
  3e:	cf ef       	ldi	r28, 0xFF	; 255
  40:	cd bf       	out	0x3d, r28	; 61
  42:	df e3       	ldi	r29, 0x3F	; 63
  44:	de bf       	out	0x3e, r29	; 62

00000046 <__do_copy_data>:
  46:	e4 e3       	ldi	r30, 0x34	; 52
  48:	f0 e0       	ldi	r31, 0x00	; 0
  4a:	40 e0       	ldi	r20, 0x00	; 0
  4c:	17 c0       	rjmp	.+46     	; 0x7c <__do_clear_bss+0x8>
  4e:	b5 91       	lpm	r27, Z+
  50:	a5 91       	lpm	r26, Z+
  52:	35 91       	lpm	r19, Z+
  54:	25 91       	lpm	r18, Z+
  56:	05 91       	lpm	r16, Z+
  58:	07 fd       	sbrc	r16, 7
  5a:	0c c0       	rjmp	.+24     	; 0x74 <__do_clear_bss>
  5c:	95 91       	lpm	r25, Z+
  5e:	85 91       	lpm	r24, Z+
  60:	ef 01       	movw	r28, r30
  62:	f9 2f       	mov	r31, r25
  64:	e8 2f       	mov	r30, r24
  66:	05 90       	lpm	r0, Z+
  68:	0d 92       	st	X+, r0
  6a:	a2 17       	cp	r26, r18
  6c:	b3 07       	cpc	r27, r19
  6e:	d9 f7       	brne	.-10     	; 0x66 <__do_copy_data+0x20>
  70:	fe 01       	movw	r30, r28
  72:	04 c0       	rjmp	.+8      	; 0x7c <__do_clear_bss+0x8>

00000074 <__do_clear_bss>:
  74:	1d 92       	st	X+, r1
  76:	a2 17       	cp	r26, r18
  78:	b3 07       	cpc	r27, r19
  7a:	e1 f7       	brne	.-8      	; 0x74 <__do_clear_bss>
  7c:	e9 33       	cpi	r30, 0x39	; 57
  7e:	f4 07       	cpc	r31, r20
  80:	31 f7       	brne	.-52     	; 0x4e <__do_copy_data+0x8>
  82:	03 d0       	rcall	.+6      	; 0x8a <_etext>
  84:	05 c3       	rjmp	.+1546   	; 0x690 <exit>

00000086 <_exit>:
  86:	f8 94       	cli

00000088 <__stop_program>:
  88:	ff cf       	rjmp	.-2      	; 0x88 <__stop_program>

Disassembly of section .text:

000006ce <__bad_interrupt>:
 6ce:	98 cc       	rjmp	.-1744   	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.wait_1us:

000006c6 <wait_1us>:
//1us縺ｮ蠕縺｡
//==============================================
static void wait_1us(void)
{

		asm("rjmp .+0");
 6c6:	00 c0       	rjmp	.+0      	; 0x6c8 <wait_1us+0x2>
 6c8:	08 95       	ret

Disassembly of section .text.spi_trans:

0000047a <spi_trans>:
static unsigned char spi_trans(			//受信したﾃﾞｰﾀを返す
	unsigned char data,			//送信するﾃﾞｰﾀ
	unsigned char sck_h)			//最終ﾋﾞｯﾄのSCKの扱い
						//　(2線SPI時のﾊﾟﾜｰﾀﾞｳﾝのため)
						//　0=Lにする､1=Hを保持する
{
 47a:	ff 92       	push	r15
 47c:	0f 93       	push	r16
 47e:	1f 93       	push	r17
 480:	cf 93       	push	r28
 482:	df 93       	push	r29
 484:	18 2f       	mov	r17, r24
 486:	f6 2e       	mov	r15, r22
	unsigned char c=8;
 488:	88 e0       	ldi	r24, 0x08	; 8

//DBS_H;
//DBG_C('(');
//DBG_B(data);
	while(c--)
 48a:	1e c0       	rjmp	.+60     	; 0x4c8 <spi_trans+0x4e>
	{
		if(data&0x80) SPI_MOSI_H;	//ﾃﾞｰﾀﾋﾞｯﾄを
 48c:	11 23       	and	r17, r17
 48e:	24 f4       	brge	.+8      	; 0x498 <spi_trans+0x1e>
 490:	80 e8       	ldi	r24, 0x80	; 128
 492:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <__RODATA_PM_OFFSET__+0x7f8405>
 496:	03 c0       	rjmp	.+6      	; 0x49e <spi_trans+0x24>
		else SPI_MOSI_L;		//　MOSIに乗せる
 498:	80 e8       	ldi	r24, 0x80	; 128
 49a:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__RODATA_PM_OFFSET__+0x7f8406>
#if defined(SPI2)||defined(SPI3)	//2線SPIまたは3線SPIのとき
		SPI_MOSI_OUT;			//MOSIを出力ﾓｰﾄﾞ
 49e:	c0 e0       	ldi	r28, 0x00	; 0
 4a0:	d4 e0       	ldi	r29, 0x04	; 4
 4a2:	80 e8       	ldi	r24, 0x80	; 128
 4a4:	89 83       	std	Y+1, r24	; 0x01
#endif
#ifdef SPI2 				//2線SPIのとき
		__disable_irq();		//割込み禁止
#endif
		SPI_SCK_H;			//SCKをH
 4a6:	94 e0       	ldi	r25, 0x04	; 4
 4a8:	9d 83       	std	Y+5, r25	; 0x05
#if defined(SPI2)||defined(SPI3)	//2線SPIまたは3線SPIのとき
		SPI_MISO_IN;			//MISOを入力ﾓｰﾄﾞ
 4aa:	8a 83       	std	Y+2, r24	; 0x02
		wait_1us();
 4ac:	0c d1       	rcall	.+536    	; 0x6c6 <wait_1us>
#endif
		data<<=1;			//ﾃﾞｰﾀを次に進める
 4ae:	11 0f       	add	r17, r17
		if(SPI_MISO) data++;		//MISOをﾃﾞｰﾀに取込む
 4b0:	88 85       	ldd	r24, Y+8	; 0x08
 4b2:	88 23       	and	r24, r24
 4b4:	0c f4       	brge	.+2      	; 0x4b8 <spi_trans+0x3e>
 4b6:	1f 5f       	subi	r17, 0xFF	; 255
		if(c||(!sck_h))			//最終ﾋﾞｯﾄ以外かﾊﾟﾜｰﾀﾞｳﾝ以外は
 4b8:	01 11       	cpse	r16, r1
 4ba:	02 c0       	rjmp	.+4      	; 0x4c0 <spi_trans+0x46>
 4bc:	f1 10       	cpse	r15, r1
 4be:	03 c0       	rjmp	.+6      	; 0x4c6 <spi_trans+0x4c>
		{
			SPI_SCK_L;		//SCKをL
 4c0:	84 e0       	ldi	r24, 0x04	; 4
 4c2:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__RODATA_PM_OFFSET__+0x7f8406>
 4c6:	80 2f       	mov	r24, r16
	unsigned char c=8;

//DBS_H;
//DBG_C('(');
//DBG_B(data);
	while(c--)
 4c8:	0f ef       	ldi	r16, 0xFF	; 255
 4ca:	08 0f       	add	r16, r24
 4cc:	81 11       	cpse	r24, r1
 4ce:	de cf       	rjmp	.-68     	; 0x48c <spi_trans+0x12>
	};
//DBG_B(data);
//DBG_C(')');
//DBS_L;
	return(data);				//受信したﾃﾞｰﾀを返す
}
 4d0:	81 2f       	mov	r24, r17
 4d2:	df 91       	pop	r29
 4d4:	cf 91       	pop	r28
 4d6:	1f 91       	pop	r17
 4d8:	0f 91       	pop	r16
 4da:	ff 90       	pop	r15
 4dc:	08 95       	ret

Disassembly of section .text.spi_reset:

000006b6 <spi_reset>:
//SPIﾘｾｯﾄ
//==============================================
static void spi_reset(void)
{

	SPI_SS_H;				//SSをﾈｹﾞｰﾄする
 6b6:	82 e0       	ldi	r24, 0x02	; 2
 6b8:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <__RODATA_PM_OFFSET__+0x7f8405>
 6bc:	08 95       	ret

Disassembly of section .text.W25_PWR_DOWN:

00000626 <W25_PWR_DOWN>:
//W25をﾊﾟﾜｰﾀﾞｳﾝ(API関数)
//==============================================
static void W25_PWR_DOWN(void)
{

	voiceS.no=0;				//音声再生終了にする
 626:	10 92 30 3f 	sts	0x3F30, r1	; 0x803f30 <voiceS+0x8>
 62a:	10 92 31 3f 	sts	0x3F31, r1	; 0x803f31 <voiceS+0x9>
	spi_reset();				//SPIをﾘｾｯﾄする
 62e:	43 d0       	rcall	.+134    	; 0x6b6 <spi_reset>
	SPI_SS_L;				//ﾁｯﾌﾟｾﾚｸﾄ
 630:	82 e0       	ldi	r24, 0x02	; 2
 632:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__RODATA_PM_OFFSET__+0x7f8406>
#ifdef SPI2				//2線SPIのとき
	spi_trans(W25_PwrDwn,1);		//ﾊﾟﾜｰﾀﾞｳﾝｺﾏﾝﾄﾞ
#else					//2線SPIでないとき
	spi_trans(W25_PwrDwn,0);		//ﾊﾟﾜｰﾀﾞｳﾝｺﾏﾝﾄﾞ
 636:	60 e0       	ldi	r22, 0x00	; 0
 638:	89 eb       	ldi	r24, 0xB9	; 185
 63a:	1f df       	rcall	.-450    	; 0x47a <spi_trans>
#endif
	spi_reset();				//SPIをﾘｾｯﾄする
 63c:	3c d0       	rcall	.+120    	; 0x6b6 <spi_reset>
 63e:	08 95       	ret

Disassembly of section .text.VOICES_SEL:

00000134 <VOICES_SEL>:
//==============================================
//音声S選択処理(API関数)
//==============================================
static void VOICES_SEL(				//戻り値無し
	unsigned short no)			//音声番号(0は再生中止)
{
 134:	cf 93       	push	r28
 136:	df 93       	push	r29

//DBG_C('\n');
//DBG_C('s');
//DBG_S(no);
//DBG_C('i');
	if(no)					//再生開始のとき
 138:	00 97       	sbiw	r24, 0x00	; 0
 13a:	09 f4       	brne	.+2      	; 0x13e <VOICES_SEL+0xa>
 13c:	47 c0       	rjmp	.+142    	; 0x1cc <VOICES_SEL+0x98>
	{
		if(no>sizeof(voiceS_idx)/sizeof(voiceS_idx[0])) return;
 13e:	84 30       	cpi	r24, 0x04	; 4
 140:	91 05       	cpc	r25, r1
 142:	08 f0       	brcs	.+2      	; 0x146 <VOICES_SEL+0x12>
 144:	48 c0       	rjmp	.+144    	; 0x1d6 <VOICES_SEL+0xa2>
						//実装数を超えているときは戻る
		if(voiceS.no!=no)		//発声中の音声番号と異なるときのみ
 146:	20 91 30 3f 	lds	r18, 0x3F30	; 0x803f30 <voiceS+0x8>
 14a:	30 91 31 3f 	lds	r19, 0x3F31	; 0x803f31 <voiceS+0x9>
 14e:	82 17       	cp	r24, r18
 150:	93 07       	cpc	r25, r19
 152:	09 f4       	brne	.+2      	; 0x156 <VOICES_SEL+0x22>
 154:	40 c0       	rjmp	.+128    	; 0x1d6 <VOICES_SEL+0xa2>
						//　音声を切り替える
		{
			voiceS.no=no--;		//音声番号を設定
 156:	fc 01       	movw	r30, r24
 158:	31 97       	sbiw	r30, 0x01	; 1
 15a:	c8 e2       	ldi	r28, 0x28	; 40
 15c:	df e3       	ldi	r29, 0x3F	; 63
 15e:	88 87       	std	Y+8, r24	; 0x08
 160:	99 87       	std	Y+9, r25	; 0x09
			voiceS.begin=voiceS_idx[no].adr;
 162:	cf 01       	movw	r24, r30
 164:	88 0f       	add	r24, r24
 166:	99 1f       	adc	r25, r25
 168:	88 0f       	add	r24, r24
 16a:	99 1f       	adc	r25, r25
 16c:	88 0f       	add	r24, r24
 16e:	99 1f       	adc	r25, r25
 170:	e8 0f       	add	r30, r24
 172:	f9 1f       	adc	r31, r25
 174:	e6 5f       	subi	r30, 0xF6	; 246
 176:	f9 47       	sbci	r31, 0x79	; 121
 178:	40 81       	ld	r20, Z
 17a:	51 81       	ldd	r21, Z+1	; 0x01
 17c:	62 81       	ldd	r22, Z+2	; 0x02
 17e:	73 81       	ldd	r23, Z+3	; 0x03
 180:	48 83       	st	Y, r20
 182:	59 83       	std	Y+1, r21	; 0x01
 184:	6a 83       	std	Y+2, r22	; 0x02
 186:	7b 83       	std	Y+3, r23	; 0x03
						//音声ﾃﾞｰﾀの開始ｱﾄﾞﾚｽを設定
//DBG_L(voiceS.begin);
			voiceS.end=voiceS.begin+voiceS_idx[no].len;
 188:	84 81       	ldd	r24, Z+4	; 0x04
 18a:	95 81       	ldd	r25, Z+5	; 0x05
 18c:	a6 81       	ldd	r26, Z+6	; 0x06
 18e:	b7 81       	ldd	r27, Z+7	; 0x07
 190:	84 0f       	add	r24, r20
 192:	95 1f       	adc	r25, r21
 194:	a6 1f       	adc	r26, r22
 196:	b7 1f       	adc	r27, r23
 198:	8c 83       	std	Y+4, r24	; 0x04
 19a:	9d 83       	std	Y+5, r25	; 0x05
 19c:	ae 83       	std	Y+6, r26	; 0x06
 19e:	bf 83       	std	Y+7, r27	; 0x07
						//音声ﾃﾞｰﾀの終了ｱﾄﾞﾚｽを設定
//DBG_L(voiceS.end);
			voiceS.ps=voiceS.psn=voiceS_idx[no].psn;
 1a0:	80 85       	ldd	r24, Z+8	; 0x08
 1a2:	8c 87       	std	Y+12, r24	; 0x0c
 1a4:	8d 87       	std	Y+13, r24	; 0x0d
						//再生処理ﾌﾟﾘｽｹｰﾙ値を設定
//DBG_B(voiceS.psn);
			voiceS.pcm=0;		//PCM値を初期化
 1a6:	1a 86       	std	Y+10, r1	; 0x0a
 1a8:	1b 86       	std	Y+11, r1	; 0x0b
//DBG_S(voiceS.pcm);
			spi_reset();		//SPIをﾘｾｯﾄする
 1aa:	85 d2       	rcall	.+1290   	; 0x6b6 <spi_reset>
			SPI_SS_L;		//ﾁｯﾌﾟｾﾚｸﾄ
 1ac:	82 e0       	ldi	r24, 0x02	; 2
 1ae:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__RODATA_PM_OFFSET__+0x7f8406>
			spi_trans(W25_ReadData,0);
 1b2:	60 e0       	ldi	r22, 0x00	; 0
 1b4:	83 e0       	ldi	r24, 0x03	; 3
 1b6:	61 d1       	rcall	.+706    	; 0x47a <spi_trans>
						//ReadDataｺﾏﾝﾄﾞ
			spi_trans(voiceS.begin>>16,0);
 1b8:	60 e0       	ldi	r22, 0x00	; 0
 1ba:	8a 81       	ldd	r24, Y+2	; 0x02
 1bc:	5e d1       	rcall	.+700    	; 0x47a <spi_trans>
						//ｱﾄﾞﾚｽ(MSB)
			spi_trans(voiceS.begin>>8,0);
 1be:	60 e0       	ldi	r22, 0x00	; 0
 1c0:	89 81       	ldd	r24, Y+1	; 0x01
 1c2:	5b d1       	rcall	.+694    	; 0x47a <spi_trans>
						//ｱﾄﾞﾚｽ
			spi_trans(voiceS.begin,0);
 1c4:	60 e0       	ldi	r22, 0x00	; 0
 1c6:	88 81       	ld	r24, Y
 1c8:	58 d1       	rcall	.+688    	; 0x47a <spi_trans>
 1ca:	05 c0       	rjmp	.+10     	; 0x1d6 <VOICES_SEL+0xa2>
						//ｱﾄﾞﾚｽ(LSB)
		}
	}
	else					//再生中断のとき
	{
		voiceS.no=0;			//再生終了にする
 1cc:	10 92 30 3f 	sts	0x3F30, r1	; 0x803f30 <voiceS+0x8>
 1d0:	10 92 31 3f 	sts	0x3F31, r1	; 0x803f31 <voiceS+0x9>
		spi_reset();			//SPIをﾘｾｯﾄする
 1d4:	70 d2       	rcall	.+1248   	; 0x6b6 <spi_reset>
	}
//DBG_D(&voiceS,sizeof(voiceS));
}
 1d6:	df 91       	pop	r29
 1d8:	cf 91       	pop	r28
 1da:	08 95       	ret

Disassembly of section .text.put_buf:

00000510 <put_buf>:
//ﾊﾞｯﾌｧへ詰める
//ﾊﾞｯﾌｧﾌﾙの場合は待合せる
//==============================================
static void put_buf(
	short pcm)				//PCMﾃﾞｰﾀ
{
 510:	ac 01       	movw	r20, r24
	unsigned char n;

//DBG_C('\n');
//DBG_C('-');
//DBG_S(pcm);
	n=buf_write;				//書込みﾎﾟｲﾝﾀを取得する
 512:	20 91 3f 3f 	lds	r18, 0x3F3F	; 0x803f3f <buf_write>
	if(++n==OUT_BUF_N) n=0;			//書込み位置を仮に進める
 516:	2f 5f       	subi	r18, 0xFF	; 255
 518:	24 31       	cpi	r18, 0x14	; 20
 51a:	09 f4       	brne	.+2      	; 0x51e <put_buf+0xe>
 51c:	20 e0       	ldi	r18, 0x00	; 0
//DBS_H;
	while(n==buf_read);			//ﾊﾞｯﾌｧが空くのを待つ
 51e:	90 91 3e 3f 	lds	r25, 0x3F3E	; 0x803f3e <buf_read>
 522:	29 17       	cp	r18, r25
 524:	e1 f3       	breq	.-8      	; 0x51e <put_buf+0xe>
//DBS_L;
	buf[buf_write]=pcm;			//ﾃﾞｰﾀをﾊﾞｯﾌｧに書込む
 526:	e0 91 3f 3f 	lds	r30, 0x3F3F	; 0x803f3f <buf_write>
 52a:	f0 e0       	ldi	r31, 0x00	; 0
 52c:	ee 0f       	add	r30, r30
 52e:	ff 1f       	adc	r31, r31
 530:	e0 50       	subi	r30, 0x00	; 0
 532:	f1 4c       	sbci	r31, 0xC1	; 193
 534:	40 83       	st	Z, r20
 536:	51 83       	std	Z+1, r21	; 0x01
	buf_write=n;				//書込みﾎﾟｲﾝﾀを更新する
 538:	20 93 3f 3f 	sts	0x3F3F, r18	; 0x803f3f <buf_write>
 53c:	08 95       	ret

Disassembly of section .text.sw_read:

0000027c <sw_read>:
	unsigned char res;			//SW評価戻り値

//DBG_C('\n');
//DBG_C('S');
//DBG_B(no);
	if(no>=SW_SU) return(0);		//SW番号が実装数を超えていたら戻る
 27c:	81 11       	cpse	r24, r1
 27e:	45 c0       	rjmp	.+138    	; 0x30a <sw_read+0x8e>
//DBG_S(sw_cnf[no].port);
	value=sw_cnf[no].port->IN&sw_cnf[no].msk;//ﾎﾟｰﾄを読込む
 280:	e8 2f       	mov	r30, r24
 282:	f0 e0       	ldi	r31, 0x00	; 0
 284:	ee 0f       	add	r30, r30
 286:	ff 1f       	adc	r31, r31
 288:	ee 0f       	add	r30, r30
 28a:	ff 1f       	adc	r31, r31
 28c:	e6 53       	subi	r30, 0x36	; 54
 28e:	f9 47       	sbci	r31, 0x79	; 121
 290:	a0 81       	ld	r26, Z
 292:	b1 81       	ldd	r27, Z+1	; 0x01
 294:	18 96       	adiw	r26, 0x08	; 8
 296:	9c 91       	ld	r25, X
 298:	91 70       	andi	r25, 0x01	; 1
//DBG_B(value);
	if(!(sw_cnf[no].mode&0x40)) value^=sw_cnf[no].msk;
 29a:	22 81       	ldd	r18, Z+2	; 0x02
 29c:	26 fd       	sbrc	r18, 6
 29e:	02 c0       	rjmp	.+4      	; 0x2a4 <sw_read+0x28>
 2a0:	31 e0       	ldi	r19, 0x01	; 1
 2a2:	93 27       	eor	r25, r19
						//負論理のときは反転する
//DBG_B(value);
	p=sw_hst+no;				//履歴へのﾎﾟｲﾝﾀを設定する
 2a4:	e8 2f       	mov	r30, r24
 2a6:	f0 e0       	ldi	r31, 0x00	; 0
 2a8:	e3 5c       	subi	r30, 0xC3	; 195
 2aa:	f0 4c       	sbci	r31, 0xC0	; 192
	if(sw_cnf[no].mode&0x80)		//ﾀｲﾏｰﾓｰﾄﾞのとき
 2ac:	22 23       	and	r18, r18
 2ae:	dc f4       	brge	.+54     	; 0x2e6 <sw_read+0x6a>
	{

	//ﾀｲﾏｰﾓｰﾄﾞの処理
#ifdef SW_TIMER				//ﾀｲﾏｰﾓｰﾄﾞを実装するとき
//DBG_C('t');
		if(value)			//SWがｵﾝのとき
 2b0:	99 23       	and	r25, r25
 2b2:	69 f0       	breq	.+26     	; 0x2ce <sw_read+0x52>
		{
//DBG_C('+');
			if((++*p==0)) --*p;	//ｵﾝ継続時間をｲﾝｸﾘして
 2b4:	90 81       	ld	r25, Z
 2b6:	81 e0       	ldi	r24, 0x01	; 1
 2b8:	89 0f       	add	r24, r25
 2ba:	80 83       	st	Z, r24
 2bc:	81 11       	cpse	r24, r1
 2be:	01 c0       	rjmp	.+2      	; 0x2c2 <sw_read+0x46>
 2c0:	90 83       	st	Z, r25
						//　ｵｰﾊﾞﾌﾛｰしたら戻す
//DBG_B(*p);
			if(*p==SW_LONG/KOYUU_PR) res=2;
 2c2:	80 81       	ld	r24, Z
 2c4:	8f 31       	cpi	r24, 0x1F	; 31
 2c6:	19 f1       	breq	.+70     	; 0x30e <sw_read+0x92>
						//長ｵﾝ閾値に一致したら｢2｣を返す
			else if(*p==SW_SHORT/KOYUU_PR) res=3;
 2c8:	83 30       	cpi	r24, 0x03	; 3
 2ca:	19 f5       	brne	.+70     	; 0x312 <sw_read+0x96>
 2cc:	08 95       	ret
		}
		else				//SWがｵﾌのとき
		{
//DBG_C('-');
//DBG_B(*p);
			if(*p>SW_LONG/KOYUU_PR) res=0;
 2ce:	80 81       	ld	r24, Z
 2d0:	80 32       	cpi	r24, 0x20	; 32
 2d2:	20 f4       	brcc	.+8      	; 0x2dc <sw_read+0x60>
						//長ｵﾝ閾値を超えていたら｢0｣を返す
			else if(*p>SW_SHORT/KOYUU_PR) res=1;
 2d4:	84 30       	cpi	r24, 0x04	; 4
 2d6:	20 f0       	brcs	.+8      	; 0x2e0 <sw_read+0x64>
 2d8:	81 e0       	ldi	r24, 0x01	; 1
 2da:	03 c0       	rjmp	.+6      	; 0x2e2 <sw_read+0x66>
		}
		else				//SWがｵﾌのとき
		{
//DBG_C('-');
//DBG_B(*p);
			if(*p>SW_LONG/KOYUU_PR) res=0;
 2dc:	80 e0       	ldi	r24, 0x00	; 0
 2de:	01 c0       	rjmp	.+2      	; 0x2e2 <sw_read+0x66>
						//長ｵﾝ閾値を超えていたら｢0｣を返す
			else if(*p>SW_SHORT/KOYUU_PR) res=1;
						//短ｵﾝ閾値を超えていたら｢1｣を返す
			else res=0;		//｢0｣を返す
 2e0:	80 e0       	ldi	r24, 0x00	; 0
			*p=0;			//履歴をｸﾘｱする
 2e2:	10 82       	st	Z, r1
 2e4:	08 95       	ret
	}
	else					//ﾘｱﾙﾓｰﾄﾞのとき
	{
//DBG_C('r');
#ifdef SW_REAL				//ﾘｱﾙﾓｰﾄﾞを実装するとき
		*p<<=1;				//履歴をｼﾌﾄしておく
 2e6:	80 81       	ld	r24, Z
 2e8:	88 0f       	add	r24, r24
 2ea:	80 83       	st	Z, r24
//DBG_B(*p);
//DBG_B(value);
		if(value) *p|=1;		//SWがｵﾝのときは最新履歴をｵﾝする
 2ec:	99 23       	and	r25, r25
 2ee:	11 f0       	breq	.+4      	; 0x2f4 <sw_read+0x78>
 2f0:	81 60       	ori	r24, 0x01	; 1
 2f2:	80 83       	st	Z, r24
//DBG_B(*p);
		switch(*p&SW_HST_MSK)		//履歴で判定する
 2f4:	80 81       	ld	r24, Z
 2f6:	8f 70       	andi	r24, 0x0F	; 15
 2f8:	87 30       	cpi	r24, 0x07	; 7
 2fa:	19 f0       	breq	.+6      	; 0x302 <sw_read+0x86>
 2fc:	8e 30       	cpi	r24, 0x0E	; 14
 2fe:	59 f0       	breq	.+22     	; 0x316 <sw_read+0x9a>
 300:	02 c0       	rjmp	.+4      	; 0x306 <sw_read+0x8a>
		{
		case SW_HST_ON:			//ｵﾝ判定ﾊﾟﾀｰﾝのときは
			res=1;			//　｢1｣を返す
 302:	81 e0       	ldi	r24, 0x01	; 1
 304:	08 95       	ret
			break;
		case SW_HST_OFF:		//ｵﾌ判定ﾊﾟﾀｰﾝのときは
			res=2;			//　｢2｣を返す
			break;
		default:			//その他のときは
			res=0;			//　｢0｣を返す
 306:	80 e0       	ldi	r24, 0x00	; 0
 308:	08 95       	ret
	unsigned char res;			//SW評価戻り値

//DBG_C('\n');
//DBG_C('S');
//DBG_B(no);
	if(no>=SW_SU) return(0);		//SW番号が実装数を超えていたら戻る
 30a:	80 e0       	ldi	r24, 0x00	; 0
 30c:	08 95       	ret
		{
//DBG_C('+');
			if((++*p==0)) --*p;	//ｵﾝ継続時間をｲﾝｸﾘして
						//　ｵｰﾊﾞﾌﾛｰしたら戻す
//DBG_B(*p);
			if(*p==SW_LONG/KOYUU_PR) res=2;
 30e:	82 e0       	ldi	r24, 0x02	; 2
 310:	08 95       	ret
						//長ｵﾝ閾値に一致したら｢2｣を返す
			else if(*p==SW_SHORT/KOYUU_PR) res=3;
						//短ｵﾝ閾値に一致したら｢3｣を返す
			else res=0;		//その他は｢0｣を返す
 312:	80 e0       	ldi	r24, 0x00	; 0
 314:	08 95       	ret
		{
		case SW_HST_ON:			//ｵﾝ判定ﾊﾟﾀｰﾝのときは
			res=1;			//　｢1｣を返す
			break;
		case SW_HST_OFF:		//ｵﾌ判定ﾊﾟﾀｰﾝのときは
			res=2;			//　｢2｣を返す
 316:	82 e0       	ldi	r24, 0x02	; 2
#else					//ﾘｱﾙﾓｰﾄﾞを実装しないとき
		res=0;
#endif
	}
	return(res);
}
 318:	08 95       	ret

Disassembly of section .text.apl_init:

00000670 <apl_init>:
//DBG_C('\n');
//DBG_C('$');

//ﾓｰﾀｰ制御ﾎﾟｰﾄ設定  24/05/23 YM 追加
	#ifdef MTR_BIT				//ﾓｰﾀｰ制御ﾎﾟｰﾄが実装されているとき
	MTR_PORT.OUTCLR=1<<MTR_BIT;		//ﾓｰﾀｰを停止　(論理反転 24/05/23 YM)
 670:	e0 e0       	ldi	r30, 0x00	; 0
 672:	f4 e0       	ldi	r31, 0x04	; 4
 674:	80 e4       	ldi	r24, 0x40	; 64
 676:	86 83       	std	Z+6, r24	; 0x06
	MTR_PORT.DIRSET=1<<MTR_BIT;		//出力ﾓｰﾄﾞ
 678:	81 83       	std	Z+1, r24	; 0x01

	//SWﾎﾟｰﾄ設定
#ifdef SW_EN				//SWを実装するとき
#ifdef SW0_BIT				//SW0を実装するとき
#ifdef SW0_INV				//入力が負論理のとき
	((PORT_tn *)&SW0_PORT)->PINnCTRL[SW0_BIT]=0b00001001;
 67a:	89 e0       	ldi	r24, 0x09	; 9
 67c:	80 8b       	std	Z+16, r24	; 0x10
 67e:	08 95       	ret

Disassembly of section .text.CB_VOICES_END:

000006be <CB_VOICES_END>:
//==============================================
static void CB_VOICES_END(void)
{
	//モータ停止を追加 24/05/23 YM
	#ifdef MTR_BIT				//ﾓｰﾀｰ制御ﾎﾟｰﾄが実装されているとき
	MTR_PORT.OUTCLR=1<<MTR_BIT;		//ﾓｰﾀｰを停止（論理反転 YM)
 6be:	80 e4       	ldi	r24, 0x40	; 64
 6c0:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__RODATA_PM_OFFSET__+0x7f8406>
 6c4:	08 95       	ret

Disassembly of section .text.voiceS_exe:

0000031a <voiceS_exe>:

//==============================================
//音声S再生処理
//==============================================
static void voiceS_exe(void)
{
 31a:	0f 93       	push	r16
 31c:	1f 93       	push	r17

//DBG_C('\n');
//DBG_C('p');
	voiceS.pcm=(short)spi_trans(0,0)-128;	//音声ﾃﾞｰﾀを取出して､
 31e:	60 e0       	ldi	r22, 0x00	; 0
 320:	80 e0       	ldi	r24, 0x00	; 0
 322:	ab d0       	rcall	.+342    	; 0x47a <spi_trans>
 324:	a8 2f       	mov	r26, r24
 326:	b0 e0       	ldi	r27, 0x00	; 0
 328:	a0 58       	subi	r26, 0x80	; 128
 32a:	b1 09       	sbc	r27, r1
						//　8ﾋﾞｯﾄPCM形式をsignedに変換
//DBG_S(voiceS.pcm);
	voiceS.pcm=(long)voiceS.pcm*((long)VOICES_VOL*PWM_STEP/100)/128;
 32c:	20 ef       	ldi	r18, 0xF0	; 240
 32e:	31 e0       	ldi	r19, 0x01	; 1
 330:	b6 d1       	rcall	.+876    	; 0x69e <__usmulhisi3>
 332:	8b 01       	movw	r16, r22
 334:	9c 01       	movw	r18, r24
 336:	99 23       	and	r25, r25
 338:	24 f4       	brge	.+8      	; 0x342 <voiceS_exe+0x28>
 33a:	01 58       	subi	r16, 0x81	; 129
 33c:	1f 4f       	sbci	r17, 0xFF	; 255
 33e:	2f 4f       	sbci	r18, 0xFF	; 255
 340:	3f 4f       	sbci	r19, 0xFF	; 255
 342:	d9 01       	movw	r26, r18
 344:	c8 01       	movw	r24, r16
 346:	68 94       	set
 348:	16 f8       	bld	r1, 6
 34a:	b5 95       	asr	r27
 34c:	a7 95       	ror	r26
 34e:	97 95       	ror	r25
 350:	87 95       	ror	r24
 352:	16 94       	lsr	r1
 354:	d1 f7       	brne	.-12     	; 0x34a <voiceS_exe+0x30>
 356:	e8 e2       	ldi	r30, 0x28	; 40
 358:	ff e3       	ldi	r31, 0x3F	; 63
 35a:	82 87       	std	Z+10, r24	; 0x0a
 35c:	93 87       	std	Z+11, r25	; 0x0b
						//音量配分を掛ける
//DBG_S(voiceS.pcm);
	if(++voiceS.begin==voiceS.end)		//音声ﾃﾞｰﾀが最後のとき
 35e:	80 81       	ld	r24, Z
 360:	91 81       	ldd	r25, Z+1	; 0x01
 362:	a2 81       	ldd	r26, Z+2	; 0x02
 364:	b3 81       	ldd	r27, Z+3	; 0x03
 366:	01 96       	adiw	r24, 0x01	; 1
 368:	a1 1d       	adc	r26, r1
 36a:	b1 1d       	adc	r27, r1
 36c:	80 83       	st	Z, r24
 36e:	91 83       	std	Z+1, r25	; 0x01
 370:	a2 83       	std	Z+2, r26	; 0x02
 372:	b3 83       	std	Z+3, r27	; 0x03
 374:	44 81       	ldd	r20, Z+4	; 0x04
 376:	55 81       	ldd	r21, Z+5	; 0x05
 378:	66 81       	ldd	r22, Z+6	; 0x06
 37a:	77 81       	ldd	r23, Z+7	; 0x07
 37c:	84 17       	cp	r24, r20
 37e:	95 07       	cpc	r25, r21
 380:	a6 07       	cpc	r26, r22
 382:	b7 07       	cpc	r27, r23
 384:	31 f4       	brne	.+12     	; 0x392 <voiceS_exe+0x78>
	{
//DBG_C('e');
		voiceS.no=0;			//再生終了にする
 386:	10 92 30 3f 	sts	0x3F30, r1	; 0x803f30 <voiceS+0x8>
 38a:	10 92 31 3f 	sts	0x3F31, r1	; 0x803f31 <voiceS+0x9>
		spi_reset();			//SPIをﾘｾｯﾄする
 38e:	93 d1       	rcall	.+806    	; 0x6b6 <spi_reset>
		CB_VOICES_END();		//音声再生終了処理(ｺｰﾙﾊﾞｯｸ関数)を呼出す
 390:	96 d1       	rcall	.+812    	; 0x6be <CB_VOICES_END>
	}
}
 392:	1f 91       	pop	r17
 394:	0f 91       	pop	r16
 396:	08 95       	ret

Disassembly of section .text.wait_us:

0000053e <wait_us>:
//==============================================
void wait_us(
	unsigned short us)			//蠕縺｡譎る俣[us]
{

	us/=2;
 53e:	96 95       	lsr	r25
 540:	87 95       	ror	r24
	while(--us)
 542:	0f c0       	rjmp	.+30     	; 0x562 <wait_us+0x24>
	{
		asm("rjmp .+0");
 544:	00 c0       	rjmp	.+0      	; 0x546 <wait_us+0x8>
		asm("rjmp .+0");
 546:	00 c0       	rjmp	.+0      	; 0x548 <wait_us+0xa>
		asm("rjmp .+0");
 548:	00 c0       	rjmp	.+0      	; 0x54a <wait_us+0xc>
		asm("rjmp .+0");
 54a:	00 c0       	rjmp	.+0      	; 0x54c <wait_us+0xe>
		asm("rjmp .+0");
 54c:	00 c0       	rjmp	.+0      	; 0x54e <wait_us+0x10>
		asm("rjmp .+0");
 54e:	00 c0       	rjmp	.+0      	; 0x550 <wait_us+0x12>
		asm("rjmp .+0");
 550:	00 c0       	rjmp	.+0      	; 0x552 <wait_us+0x14>
		asm("rjmp .+0");
 552:	00 c0       	rjmp	.+0      	; 0x554 <wait_us+0x16>
		asm("rjmp .+0");
 554:	00 c0       	rjmp	.+0      	; 0x556 <wait_us+0x18>
		asm("rjmp .+0");
 556:	00 c0       	rjmp	.+0      	; 0x558 <wait_us+0x1a>
		asm("rjmp .+0");
 558:	00 c0       	rjmp	.+0      	; 0x55a <wait_us+0x1c>
		asm("rjmp .+0");
 55a:	00 c0       	rjmp	.+0      	; 0x55c <wait_us+0x1e>
		asm("rjmp .+0");
 55c:	00 c0       	rjmp	.+0      	; 0x55e <wait_us+0x20>
		asm("rjmp .+0");
 55e:	00 c0       	rjmp	.+0      	; 0x560 <wait_us+0x22>
		asm("rjmp .+0");
 560:	00 c0       	rjmp	.+0      	; 0x562 <wait_us+0x24>
void wait_us(
	unsigned short us)			//蠕縺｡譎る俣[us]
{

	us/=2;
	while(--us)
 562:	01 97       	sbiw	r24, 0x01	; 1
 564:	79 f7       	brne	.-34     	; 0x544 <wait_us+0x6>
		asm("rjmp .+0");
		asm("rjmp .+0");
		asm("rjmp .+0");
		asm("rjmp .+0");
	}
}
 566:	08 95       	ret

Disassembly of section .text.wait_ms:

000005ee <wait_ms>:
//==============================================
//ms蜊倅ｽ阪ｮ蠕縺｡
//==============================================
static void wait_ms(
	unsigned short ms)			//蠕縺｡譎る俣[ms]
{
 5ee:	cf 93       	push	r28
 5f0:	df 93       	push	r29

	while(ms--)
 5f2:	04 c0       	rjmp	.+8      	; 0x5fc <wait_ms+0xe>
	{
		wait_us(1000);
 5f4:	88 ee       	ldi	r24, 0xE8	; 232
 5f6:	93 e0       	ldi	r25, 0x03	; 3
 5f8:	a2 df       	rcall	.-188    	; 0x53e <wait_us>
//==============================================
static void wait_ms(
	unsigned short ms)			//蠕縺｡譎る俣[ms]
{

	while(ms--)
 5fa:	ce 01       	movw	r24, r28
 5fc:	ec 01       	movw	r28, r24
 5fe:	21 97       	sbiw	r28, 0x01	; 1
 600:	89 2b       	or	r24, r25
 602:	c1 f7       	brne	.-16     	; 0x5f4 <wait_ms+0x6>
	{
		wait_us(1000);
	}
}
 604:	df 91       	pop	r29
 606:	cf 91       	pop	r28
 608:	08 95       	ret

Disassembly of section .text.W25_PWR_UP:

00000640 <W25_PWR_UP>:
//W25をﾊﾟﾜｰｱｯﾌﾟ(API関数)
//==============================================
static void W25_PWR_UP(void)
{

	spi_reset();				//SPIをﾘｾｯﾄする
 640:	3a d0       	rcall	.+116    	; 0x6b6 <spi_reset>
	wait_us(10);
 642:	8a e0       	ldi	r24, 0x0A	; 10
 644:	90 e0       	ldi	r25, 0x00	; 0
 646:	7b df       	rcall	.-266    	; 0x53e <wait_us>
	SPI_SS_L;				//ﾁｯﾌﾟｾﾚｸﾄ
 648:	82 e0       	ldi	r24, 0x02	; 2
 64a:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__RODATA_PM_OFFSET__+0x7f8406>
#ifdef SPI2				//2線SPIのとき
	spi_trans(W25_Re_PwrDwn,1);		//ﾊﾟﾜｰﾀﾞｳﾝ解除ｺﾏﾝﾄﾞ
#else					//2線SPIでないとき
	spi_trans(W25_Re_PwrDwn,0);		//ﾊﾟﾜｰﾀﾞｳﾝ解除ｺﾏﾝﾄﾞ
 64e:	60 e0       	ldi	r22, 0x00	; 0
 650:	8b ea       	ldi	r24, 0xAB	; 171
 652:	13 df       	rcall	.-474    	; 0x47a <spi_trans>
#endif
	spi_reset();				//SPIをﾘｾｯﾄする
 654:	30 d0       	rcall	.+96     	; 0x6b6 <spi_reset>
 656:	08 95       	ret

Disassembly of section .text.__vector_8:

0000040a <__vector_8>:
//==============================================
//TCA0ｵｰﾊﾞﾌﾛｰ(PWM周期)割込みﾊﾝﾄﾞﾗ
//・ﾊﾞｯﾌｧｱﾝﾀﾞｰﾗﾝ時はDCを更新しない(前回の値が継続する)
//==============================================
ISR(TCA0_OVF_vect)
{
 40a:	1f 92       	push	r1
 40c:	0f 92       	push	r0
 40e:	0f b6       	in	r0, 0x3f	; 63
 410:	0f 92       	push	r0
 412:	11 24       	eor	r1, r1
 414:	2f 93       	push	r18
 416:	8f 93       	push	r24
 418:	9f 93       	push	r25
 41a:	ef 93       	push	r30
 41c:	ff 93       	push	r31
	short data;

//DBS_H;
//DBG_C('[');
	TCA0.SINGLE.INTFLAGS=0b00000001;	//ｵｰﾊﾞｰﾌﾛｰ割込みﾌﾗｸﾞをｸﾘｱ
 41e:	81 e0       	ldi	r24, 0x01	; 1
 420:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <__RODATA_PM_OFFSET__+0x7f8a0b>

	//ﾃﾞｰﾀを取得
	if(buf_read==buf_write) return;		//ﾃﾞｰﾀが無かったら戻る
 424:	90 91 3e 3f 	lds	r25, 0x3F3E	; 0x803f3e <buf_read>
 428:	80 91 3f 3f 	lds	r24, 0x3F3F	; 0x803f3f <buf_write>
 42c:	98 17       	cp	r25, r24
 42e:	d9 f0       	breq	.+54     	; 0x466 <__vector_8+0x5c>
	data=buf[buf_read];			//ﾃﾞｰﾀを取出す
 430:	e0 91 3e 3f 	lds	r30, 0x3F3E	; 0x803f3e <buf_read>
 434:	f0 e0       	ldi	r31, 0x00	; 0
 436:	ee 0f       	add	r30, r30
 438:	ff 1f       	adc	r31, r31
 43a:	e0 50       	subi	r30, 0x00	; 0
 43c:	f1 4c       	sbci	r31, 0xC1	; 193
 43e:	80 81       	ld	r24, Z
 440:	91 81       	ldd	r25, Z+1	; 0x01
//DBG_S(data);
	if(buf_read==(OUT_BUF_N-1)) buf_read=0;	//ﾊﾞｯﾌｧの後尾になったら先頭に戻す
 442:	20 91 3e 3f 	lds	r18, 0x3F3E	; 0x803f3e <buf_read>
 446:	23 31       	cpi	r18, 0x13	; 19
 448:	19 f4       	brne	.+6      	; 0x450 <__vector_8+0x46>
 44a:	10 92 3e 3f 	sts	0x3F3E, r1	; 0x803f3e <buf_read>
 44e:	05 c0       	rjmp	.+10     	; 0x45a <__vector_8+0x50>
	else buf_read++;			//ﾊﾞｯﾌｧを進める
 450:	20 91 3e 3f 	lds	r18, 0x3F3E	; 0x803f3e <buf_read>
 454:	2f 5f       	subi	r18, 0xFF	; 255
 456:	20 93 3e 3f 	sts	0x3F3E, r18	; 0x803f3e <buf_read>

	//ﾃﾞｭｰﾃｨを更新
#if BTL==0				//ｼﾝｸﾞﾙ出力のとき
	TCA0.SINGLE.CMP0BUF=PWM_STEP/2+data;	//正相を設定
 45a:	88 50       	subi	r24, 0x08	; 8
 45c:	9f 4f       	sbci	r25, 0xFF	; 255
 45e:	80 93 38 0a 	sts	0x0A38, r24	; 0x800a38 <__RODATA_PM_OFFSET__+0x7f8a38>
 462:	90 93 39 0a 	sts	0x0A39, r25	; 0x800a39 <__RODATA_PM_OFFSET__+0x7f8a39>
//DBG_S(TCA0.SINGLE.CMP0BUF);
//DBG_S(TCA0.SINGLE.CMP1BUF);
#endif
//DBG_C(']');
//DBS_L;
}
 466:	ff 91       	pop	r31
 468:	ef 91       	pop	r30
 46a:	9f 91       	pop	r25
 46c:	8f 91       	pop	r24
 46e:	2f 91       	pop	r18
 470:	0f 90       	pop	r0
 472:	0f be       	out	0x3f, r0	; 63
 474:	0f 90       	pop	r0
 476:	1f 90       	pop	r1
 478:	18 95       	reti

Disassembly of section .text.pwm_wait:

00000680 <pwm_wait>:
//PWM周期を待つ
//==============================================
void pwm_wait(void)
{

	TCA0.SINGLE.INTFLAGS=0b00000001;	//TCA0ｵｰﾊﾞｰﾌﾛｰ割込みﾌﾗｸﾞをｸﾘｱ
 680:	81 e0       	ldi	r24, 0x01	; 1
 682:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <__RODATA_PM_OFFSET__+0x7f8a0b>
	while(!(TCA0.SINGLE.INTFLAGS&0b00000001));
 686:	80 91 0b 0a 	lds	r24, 0x0A0B	; 0x800a0b <__RODATA_PM_OFFSET__+0x7f8a0b>
 68a:	80 ff       	sbrs	r24, 0
 68c:	fc cf       	rjmp	.-8      	; 0x686 <pwm_wait+0x6>
						//PWM周期満了を待つ
}
 68e:	08 95       	ret

Disassembly of section .text.CB_INIT:

000001dc <CB_INIT>:
//==============================================
static void CB_INIT(void)
{

	//ｼｽﾃﾑ設定
	ccp_write_io((void*)&(CLKCTRL.MCLKCTRLB),0);
 1dc:	60 e0       	ldi	r22, 0x00	; 0
 1de:	81 e6       	ldi	r24, 0x61	; 97
 1e0:	90 e0       	ldi	r25, 0x00	; 0
 1e2:	63 d2       	rcall	.+1222   	; 0x6aa <ccp_write_io>
						//OSCﾌﾟﾘｽｹ無し(主ｸﾛｯｸ16MHz)
						//　ﾋｭｰｽﾞで16MHzｸﾛｯｸを選択しておくこと
	SLPCTRL.CTRLA=0b00000101;		//ﾊﾟﾜｰﾀﾞｳﾝﾓｰﾄﾞ､Sleep許可
 1e4:	85 e0       	ldi	r24, 0x05	; 5
 1e6:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__RODATA_PM_OFFSET__+0x7f8050>
#endif
#endif

	//SPIﾎﾟｰﾄ設定
#if VOICE_C+VOICE_S>0			//SPIを使うとき
	SPI_SS_OUT;				//SSを出力ﾓｰﾄﾞ
 1ea:	e0 e0       	ldi	r30, 0x00	; 0
 1ec:	f4 e0       	ldi	r31, 0x04	; 4
 1ee:	82 e0       	ldi	r24, 0x02	; 2
 1f0:	81 83       	std	Z+1, r24	; 0x01
	SPI_MISO_IN;				//MISOをﾌﾟﾙﾀﾞｳﾝ入力ﾓｰﾄﾞ
 1f2:	90 e8       	ldi	r25, 0x80	; 128
 1f4:	92 83       	std	Z+2, r25	; 0x02
	SPI_SCK_OUT;				//SCKを出力ﾓｰﾄﾞ
 1f6:	24 e0       	ldi	r18, 0x04	; 4
 1f8:	21 83       	std	Z+1, r18	; 0x01
	SPI_MOSI_OUT;				//MOSIを出力ﾓｰﾄﾞ
 1fa:	91 83       	std	Z+1, r25	; 0x01

	//PWM(TCA0)設定
#if BTL==2				//ﾌﾞﾘｯｼﾞ出力のとき
	TCA0.SINGLE.PER=PWM_STEP+PWM_DB;	//PWM周期=32.125us+ﾃﾞｯﾄﾞﾊﾞﾝﾄﾞ
#else					//ｼﾝｸﾞﾙ･ｺﾝﾌﾟﾘ･ﾌﾞﾚｰｷ出力のとき
	TCA0.SINGLE.PER=PWM_STEP;		//PWM周期=32.125us
 1fc:	a0 e0       	ldi	r26, 0x00	; 0
 1fe:	ba e0       	ldi	r27, 0x0A	; 10
 200:	20 ef       	ldi	r18, 0xF0	; 240
 202:	31 e0       	ldi	r19, 0x01	; 1
 204:	96 96       	adiw	r26, 0x26	; 38
 206:	2d 93       	st	X+, r18
 208:	3c 93       	st	X, r19
 20a:	97 97       	sbiw	r26, 0x27	; 39
#endif
#ifdef PWM_SLOW				//PWMを極端に遅くするとき
	TCA0.SINGLE.CTRLA=0b00001111;		//ｸﾛｯｸ分周1/1024(ﾃﾞﾊﾞｸﾞ用)､TCA許可
#else
	TCA0.SINGLE.CTRLA=0b00000001;		//ｸﾛｯｸ分周無し､TCA許可
 20c:	91 e0       	ldi	r25, 0x01	; 1
 20e:	9c 93       	st	X, r25
#endif
#if BTL==0				//ｼﾝｸﾞﾙ出力のとき
	TCA0.SINGLE.CTRLB=0b00010011;		//正相(WO0)を出力､ｼﾝｸﾞﾙｽﾛｰﾌﾟ動作
 210:	23 e1       	ldi	r18, 0x13	; 19
 212:	11 96       	adiw	r26, 0x01	; 1
 214:	2c 93       	st	X, r18
 216:	11 97       	sbiw	r26, 0x01	; 1
	((PORT_tn *)&PWM_F_PORT)->PINnCTRL[PWM_F_BIT]=0b10000000;
						//正相を反転出力
	((PORT_tn *)&PWM_R_PORT)->PINnCTRL[PWM_R_BIT]=0b10000000;
						//逆相を反転出力
#endif
	TCA0.SINGLE.INTCTRL=0b00000001;		//ｵｰﾊﾞｰﾌﾛｰ割込み許可
 218:	1a 96       	adiw	r26, 0x0a	; 10
 21a:	9c 93       	st	X, r25

	//PWMﾎﾟｰﾄを出力設定
	PWM_F_PORT.DIRSET=(1<<PWM_F_BIT);	//正相を出力ﾓｰﾄﾞ
 21c:	98 e0       	ldi	r25, 0x08	; 8
 21e:	91 83       	std	Z+1, r25	; 0x01
	PWM_R_PORT.DIRSET=(1<<PWM_R_BIT);	//逆相を出力ﾓｰﾄﾞ
 220:	81 83       	std	Z+1, r24	; 0x01

	//ﾗﾝﾌﾟ上昇
#if BTL==0				//ｼﾝｸﾞﾙ出力のとき
	while(TCA0.SINGLE.CMP0BUF<PWM_STEP/2)	//PCMﾚﾍﾞﾙ0まで上昇させる
 222:	08 c0       	rjmp	.+16     	; 0x234 <CB_INIT+0x58>
	{
		TCA0.SINGLE.CMP0BUF++;		//DCをｲﾝｸﾘする
 224:	e0 e0       	ldi	r30, 0x00	; 0
 226:	fa e0       	ldi	r31, 0x0A	; 10
 228:	80 ad       	ldd	r24, Z+56	; 0x38
 22a:	91 ad       	ldd	r25, Z+57	; 0x39
 22c:	01 96       	adiw	r24, 0x01	; 1
 22e:	80 af       	std	Z+56, r24	; 0x38
 230:	91 af       	std	Z+57, r25	; 0x39
		pwm_wait();			//ｻﾝﾌﾟﾘﾝｸﾞ周期を待つ
 232:	26 d2       	rcall	.+1100   	; 0x680 <pwm_wait>
	PWM_F_PORT.DIRSET=(1<<PWM_F_BIT);	//正相を出力ﾓｰﾄﾞ
	PWM_R_PORT.DIRSET=(1<<PWM_R_BIT);	//逆相を出力ﾓｰﾄﾞ

	//ﾗﾝﾌﾟ上昇
#if BTL==0				//ｼﾝｸﾞﾙ出力のとき
	while(TCA0.SINGLE.CMP0BUF<PWM_STEP/2)	//PCMﾚﾍﾞﾙ0まで上昇させる
 234:	80 91 38 0a 	lds	r24, 0x0A38	; 0x800a38 <__RODATA_PM_OFFSET__+0x7f8a38>
 238:	90 91 39 0a 	lds	r25, 0x0A39	; 0x800a39 <__RODATA_PM_OFFSET__+0x7f8a39>
 23c:	88 3f       	cpi	r24, 0xF8	; 248
 23e:	91 05       	cpc	r25, r1
 240:	88 f3       	brcs	.-30     	; 0x224 <CB_INIT+0x48>
	}
#endif
//DBG_C('P');

	//RTC設定
	ccp_write_io((void*)&(CLKCTRL.OSC32KCTRLA),CLKCTRL_RUNSTDBY_bm);
 242:	62 e0       	ldi	r22, 0x02	; 2
 244:	88 e7       	ldi	r24, 0x78	; 120
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	30 d2       	rcall	.+1120   	; 0x6aa <ccp_write_io>
						//32kOSCを常時稼働
	RTC.CLKSEL=RTC_CLKSEL_INT1K_gc;		//ｸﾛｯｸ源は内部1kHzOSC
 24a:	e0 e4       	ldi	r30, 0x40	; 64
 24c:	f1 e0       	ldi	r31, 0x01	; 1
 24e:	81 e0       	ldi	r24, 0x01	; 1
 250:	87 83       	std	Z+7, r24	; 0x07
	RTC.PITCTRLA=RTC_PERIOD_CYC32_gc|RTC_PITEN_bm;
 252:	91 e2       	ldi	r25, 0x21	; 33
 254:	90 8b       	std	Z+16, r25	; 0x10
	void song_idx_dmy(void);		//song_idxのｴﾝﾄﾘ
	song_idx_dmy();				//ﾀﾞﾐｰｺｰﾙする
#endif

	//ADC設定
	ADC0.CTRLA=0b00000001;			//10ﾋﾞｯﾄ分解能､自由走行しない､ADC有効
 256:	e0 e0       	ldi	r30, 0x00	; 0
 258:	f6 e0       	ldi	r31, 0x06	; 6
 25a:	80 83       	st	Z, r24
	ADC0.CTRLC=0b00010011;			//基準電圧はVDD､ｸﾛｯｸは1/16
 25c:	83 e1       	ldi	r24, 0x13	; 19
 25e:	82 83       	std	Z+2, r24	; 0x02

	//空きﾎﾟｰﾄをﾌﾟﾙｱｯﾌﾟ
	PORTA.PIN0CTRL=0b00001000;
 260:	e0 e0       	ldi	r30, 0x00	; 0
 262:	f4 e0       	ldi	r31, 0x04	; 4
 264:	88 e0       	ldi	r24, 0x08	; 8
 266:	80 8b       	std	Z+16, r24	; 0x10
	PORTA.PIN1CTRL=0b00001000;
 268:	81 8b       	std	Z+17, r24	; 0x11
	PORTA.PIN2CTRL=0b00001000;
 26a:	82 8b       	std	Z+18, r24	; 0x12
	PORTA.PIN3CTRL=0b00001000;
 26c:	83 8b       	std	Z+19, r24	; 0x13
	PORTA.PIN4CTRL=0b00001000;
 26e:	84 8b       	std	Z+20, r24	; 0x14
	PORTA.PIN5CTRL=0b00001000;
 270:	85 8b       	std	Z+21, r24	; 0x15
	PORTA.PIN6CTRL=0b00001000;
 272:	86 8b       	std	Z+22, r24	; 0x16
	PORTA.PIN7CTRL=0b00001000;
 274:	87 8b       	std	Z+23, r24	; 0x17
	PORTC.PIN2CTRL=0b00001000;
	PORTC.PIN3CTRL=0b00001000;
#endif

	//ｱﾌﾟﾘの初期設定(LED設定はｱﾌﾟﾘの初期化で実施)
	apl_init();
 276:	fc d1       	rcall	.+1016   	; 0x670 <apl_init>

	//動作開始
	sei();					//割込み許可
 278:	78 94       	sei
 27a:	08 95       	ret

Disassembly of section .text.dev_pwm_stop:

00000568 <dev_pwm_stop>:
{

//DBG_C('\n');
//DBG_C('s');
	//PWM割込み停止
	TCA0.SINGLE.INTCTRL=0b00000000;		//ｵｰﾊﾞｰﾌﾛｰ割込み禁止
 568:	10 92 0a 0a 	sts	0x0A0A, r1	; 0x800a0a <__RODATA_PM_OFFSET__+0x7f8a0a>
	pwm_wait();				//ｻﾝﾌﾟﾘﾝｸﾞ周期を待つ
 56c:	89 d0       	rcall	.+274    	; 0x680 <pwm_wait>

#if BTL==0				//ｼﾝｸﾞﾙ出力のとき
//DBG_C('1');
	while(TCA0.SINGLE.CMP0BUF)		//DCを0までﾗﾝﾌﾟ下降させる
 56e:	08 c0       	rjmp	.+16     	; 0x580 <dev_pwm_stop+0x18>
	{
		TCA0.SINGLE.CMP0BUF--;		//DCをﾃﾞｸﾘする
 570:	e0 e0       	ldi	r30, 0x00	; 0
 572:	fa e0       	ldi	r31, 0x0A	; 10
 574:	80 ad       	ldd	r24, Z+56	; 0x38
 576:	91 ad       	ldd	r25, Z+57	; 0x39
 578:	01 97       	sbiw	r24, 0x01	; 1
 57a:	80 af       	std	Z+56, r24	; 0x38
 57c:	91 af       	std	Z+57, r25	; 0x39
		pwm_wait();			//ｻﾝﾌﾟﾘﾝｸﾞ周期を待つ
 57e:	80 d0       	rcall	.+256    	; 0x680 <pwm_wait>
	TCA0.SINGLE.INTCTRL=0b00000000;		//ｵｰﾊﾞｰﾌﾛｰ割込み禁止
	pwm_wait();				//ｻﾝﾌﾟﾘﾝｸﾞ周期を待つ

#if BTL==0				//ｼﾝｸﾞﾙ出力のとき
//DBG_C('1');
	while(TCA0.SINGLE.CMP0BUF)		//DCを0までﾗﾝﾌﾟ下降させる
 580:	80 91 38 0a 	lds	r24, 0x0A38	; 0x800a38 <__RODATA_PM_OFFSET__+0x7f8a38>
 584:	90 91 39 0a 	lds	r25, 0x0A39	; 0x800a39 <__RODATA_PM_OFFSET__+0x7f8a39>
 588:	89 2b       	or	r24, r25
 58a:	91 f7       	brne	.-28     	; 0x570 <dev_pwm_stop+0x8>
						//逆相を非反転出力
	pwm_wait();				//ｻﾝﾌﾟﾘﾝｸﾞ周期を待つ
#endif
#endif
//DBG_C('6');
}
 58c:	08 95       	ret

Disassembly of section .text.dev_pwm_start:

0000058e <dev_pwm_start>:

//DBG_C('\n');
//DBG_C('r');
#if BTL==0				//ｼﾝｸﾞﾙ出力のとき
//DBG_C('6');
	while(TCA0.SINGLE.CMP0BUF++<PWM_STEP/2)
 58e:	01 c0       	rjmp	.+2      	; 0x592 <dev_pwm_start+0x4>
						//DCが50%になるまでｲﾝｸﾘする
	{
		pwm_wait();			//ｻﾝﾌﾟﾘﾝｸﾞ周期を待つ
 590:	77 d0       	rcall	.+238    	; 0x680 <pwm_wait>

//DBG_C('\n');
//DBG_C('r');
#if BTL==0				//ｼﾝｸﾞﾙ出力のとき
//DBG_C('6');
	while(TCA0.SINGLE.CMP0BUF++<PWM_STEP/2)
 592:	e0 e0       	ldi	r30, 0x00	; 0
 594:	fa e0       	ldi	r31, 0x0A	; 10
 596:	80 ad       	ldd	r24, Z+56	; 0x38
 598:	91 ad       	ldd	r25, Z+57	; 0x39
 59a:	9c 01       	movw	r18, r24
 59c:	2f 5f       	subi	r18, 0xFF	; 255
 59e:	3f 4f       	sbci	r19, 0xFF	; 255
 5a0:	20 af       	std	Z+56, r18	; 0x38
 5a2:	31 af       	std	Z+57, r19	; 0x39
 5a4:	88 3f       	cpi	r24, 0xF8	; 248
 5a6:	91 05       	cpc	r25, r1
 5a8:	98 f3       	brcs	.-26     	; 0x590 <dev_pwm_start+0x2>
	((PORT_tn *)&PWM_R_PORT)->PINnCTRL[PWM_R_BIT]=0b10000000;
						//逆相を反転出力
#endif

	//PWM割込み再開
	TCA0.SINGLE.INTCTRL=0b00000001;		//ｵｰﾊﾞｰﾌﾛｰ割込み許可
 5aa:	81 e0       	ldi	r24, 0x01	; 1
 5ac:	80 93 0a 0a 	sts	0x0A0A, r24	; 0x800a0a <__RODATA_PM_OFFSET__+0x7f8a0a>
 5b0:	08 95       	ret

Disassembly of section .text.apl_sleep:

000004de <apl_sleep>:
#ifdef	SLEEP_EN			//Sleep機能を実装するとき
//==============================================
//Sleep処理
//==============================================
static void apl_sleep(void)
{
 4de:	cf 93       	push	r28
 4e0:	df 93       	push	r29
	//ﾓｰﾀｰ停止;　24/05/23 追加 YM
	#ifdef MTR_BIT				//ﾓｰﾀｰ制御ﾎﾟｰﾄが実装されているとき
	MTR_PORT.OUTCLR=1<<MTR_BIT;		//ﾓｰﾀｰを停止　（論理反転　YM）
 4e2:	c0 e0       	ldi	r28, 0x00	; 0
 4e4:	d4 e0       	ldi	r29, 0x04	; 4
 4e6:	80 e4       	ldi	r24, 0x40	; 64
 4e8:	8e 83       	std	Y+6, r24	; 0x06
#endif

#if VOICE_S>0
	//W25をﾊﾟﾜｰﾀﾞｳﾝ
//DBG_C('a');
	W25_PWR_DOWN();				//W25をﾊﾟﾜｰﾀﾞｳﾝする
 4ea:	9d d0       	rcall	.+314    	; 0x626 <W25_PWR_DOWN>
#endif

	//PWMを停止
//DBG_C('b');
	dev_pwm_stop();				//PWMを停止する
 4ec:	3d d0       	rcall	.+122    	; 0x568 <dev_pwm_stop>

#else					//CdSもCVDも実装しないとき(TRGモード時追加　YM)
	//SLEEPDEEPﾓｰﾄﾞへ移行
//DBG_C('i');
DBG_SYNC();
	TRG_PORT.DIRCLR=1<<TRG_BIT;		//ﾄﾘｶﾞﾎﾟｰﾄを入力ﾓｰﾄﾞ
 4ee:	81 e0       	ldi	r24, 0x01	; 1
 4f0:	8a 83       	std	Y+2, r24	; 0x02
//	((PORT_tn *)&TRG_PORT)->PINnCTRL[TRG_BIT]=0b00000001;
	((PORT_tn *)&TRG_PORT)->PINnCTRL[TRG_BIT]=0b00001001;
 4f2:	89 e0       	ldi	r24, 0x09	; 9
 4f4:	88 8b       	std	Y+16, r24	; 0x10
	//ﾄﾘｶﾞをﾌﾟﾙｱｯﾌﾟしない､割込みする（SW0でテストのためプルアップ入れる）
//	((PORT_tn *)&TRG_PORT)->PINnCTRL[TRG_BIT]=0b00000001;
	//ﾄﾘｶﾞをﾌﾟﾙｱｯﾌﾟしない､割込みする（piezoでテストのためプルアップ外す）		
	wait_ms(10);				//電圧安定時間を待つ
 4f6:	8a e0       	ldi	r24, 0x0A	; 10
 4f8:	90 e0       	ldi	r25, 0x00	; 0
 4fa:	79 d0       	rcall	.+242    	; 0x5ee <wait_ms>
	PORTA.INTFLAGS=0xff;			//ﾋﾟﾝ変化割込みﾌﾗｸﾞをｸﾘｱする
 4fc:	8f ef       	ldi	r24, 0xFF	; 255
 4fe:	89 87       	std	Y+9, r24	; 0x09
	
	sleep_cpu();				//割込みが発生するまでSleepする
 500:	88 95       	sleep
//	((PORT_tn *)&TRG_PORT)->PINnCTRL[TRG_BIT]=0b00000000;
	((PORT_tn *)&TRG_PORT)->PINnCTRL[TRG_BIT]=0b00001000;
 502:	88 e0       	ldi	r24, 0x08	; 8
 504:	88 8b       	std	Y+16, r24	; 0x10
//DBG_C('j');
#endif

	//PWMを再稼働
//DBG_C('l');
	dev_pwm_start();			//PWMを開始する
 506:	43 d0       	rcall	.+134    	; 0x58e <dev_pwm_start>

	//W25をﾊﾟﾜｰｱｯﾌﾟ
#if	VOICE_S>0
//DBG_C('m');
	W25_PWR_UP();				//W25をﾊﾟﾜｰｱｯﾌﾟする
 508:	9b d0       	rcall	.+310    	; 0x640 <W25_PWR_UP>
#endif
//DBG_C('>');
}
 50a:	df 91       	pop	r29
 50c:	cf 91       	pop	r28
 50e:	08 95       	ret

Disassembly of section .text.CB_KOYUU:

00000398 <CB_KOYUU>:
#endif
#if VOICE_C>0				//音声C再生を実装するとき
	res|=voiceC.no;				//稼働しているときは稼働中の設定
#endif
#if VOICE_S>0				//音声S再生を実装するとき
	res|=voiceS.no;				//稼働しているときは稼働中の設定
 398:	80 91 30 3f 	lds	r24, 0x3F30	; 0x803f30 <voiceS+0x8>
#endif
//DBG_B(res);
	if(res)					//稼働しているときは
 39c:	88 23       	and	r24, r24
 39e:	29 f0       	breq	.+10     	; 0x3aa <CB_KOYUU+0x12>
	{
		sleep_tmr=0;			//　Sleep時限をｸﾘｱする
 3a0:	10 92 3a 3f 	sts	0x3F3A, r1	; 0x803f3a <sleep_tmr.3121>
 3a4:	10 92 3b 3f 	sts	0x3F3B, r1	; 0x803f3b <sleep_tmr.3121+0x1>
 3a8:	10 c0       	rjmp	.+32     	; 0x3ca <CB_KOYUU+0x32>
	}
	else					//稼働していないときは
	{
//DBG_C('X');
//DBG_S(sleep_tmr);
		if(++sleep_tmr>SLEEP_TMR/KOYUU_PR)
 3aa:	80 91 3a 3f 	lds	r24, 0x3F3A	; 0x803f3a <sleep_tmr.3121>
 3ae:	90 91 3b 3f 	lds	r25, 0x3F3B	; 0x803f3b <sleep_tmr.3121+0x1>
 3b2:	01 96       	adiw	r24, 0x01	; 1
 3b4:	80 93 3a 3f 	sts	0x3F3A, r24	; 0x803f3a <sleep_tmr.3121>
 3b8:	90 93 3b 3f 	sts	0x3F3B, r25	; 0x803f3b <sleep_tmr.3121+0x1>
 3bc:	80 97       	sbiw	r24, 0x20	; 32
 3be:	28 f0       	brcs	.+10     	; 0x3ca <CB_KOYUU+0x32>
						//　Sleep時限を超えたら
		{
			apl_sleep();		//　Sleepする
 3c0:	8e d0       	rcall	.+284    	; 0x4de <apl_sleep>
			sleep_tmr=0;		//　Sleep時限をｸﾘｱする
 3c2:	10 92 3a 3f 	sts	0x3F3A, r1	; 0x803f3a <sleep_tmr.3121>
 3c6:	10 92 3b 3f 	sts	0x3F3B, r1	; 0x803f3b <sleep_tmr.3121+0x1>

	//操作ﾁｪｯｸ
	res=0;					//仮に操作無しにしておく
#ifdef SW_EN				//SWを実装するとき
//DBG_C('s');
	if(!res) res=sw_read(0);		//SW0を評価する
 3ca:	80 e0       	ldi	r24, 0x00	; 0
 3cc:	57 df       	rcall	.-338    	; 0x27c <sw_read>
	if(!res) res=cvd_read(0);		//CVD0を評価する
//DBG_B(res);
#endif

	//操作の実行
	switch(res)				//操作内容で処理する
 3ce:	81 30       	cpi	r24, 0x01	; 1
 3d0:	19 f0       	breq	.+6      	; 0x3d8 <CB_KOYUU+0x40>
 3d2:	82 30       	cpi	r24, 0x02	; 2
 3d4:	99 f0       	breq	.+38     	; 0x3fc <CB_KOYUU+0x64>
 3d6:	08 95       	ret
		break;
	case 1:				//短ｵﾝ検知のとき
	
//モータ稼働追加　24/05/23 YM
#ifdef MTR_BIT				//ﾓｰﾀｰ制御ﾎﾟｰﾄが実装されているとき
MTR_PORT.OUTSET=1<<MTR_BIT;		//ﾓｰﾀｰを稼働（論理反転 YM)
 3d8:	80 e4       	ldi	r24, 0x40	; 64
 3da:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <__RODATA_PM_OFFSET__+0x7f8405>
						//ﾗﾝﾀﾞﾑに増加する
//DBG_B(onseiS);
		while(onseiS>VOICES_SU) onseiS-=VOICES_SU;
						//実装数内に収める
#else					//音声S番号を順に進めるとき
		if(++onseiS>VOICES_SU) onseiS=1;
 3de:	80 91 3c 3f 	lds	r24, 0x3F3C	; 0x803f3c <onseiS>
 3e2:	8f 5f       	subi	r24, 0xFF	; 255
 3e4:	80 93 3c 3f 	sts	0x3F3C, r24	; 0x803f3c <onseiS>
 3e8:	84 30       	cpi	r24, 0x04	; 4
 3ea:	18 f0       	brcs	.+6      	; 0x3f2 <CB_KOYUU+0x5a>
 3ec:	81 e0       	ldi	r24, 0x01	; 1
 3ee:	80 93 3c 3f 	sts	0x3F3C, r24	; 0x803f3c <onseiS>
						//音声番号を進める
//DBG_B(onseiS);
#endif
//DBG_B(onseiS);
		VOICES_SEL(onseiS);		//再生開始する
 3f2:	80 91 3c 3f 	lds	r24, 0x3F3C	; 0x803f3c <onseiS>
 3f6:	90 e0       	ldi	r25, 0x00	; 0
 3f8:	9d de       	rcall	.-710    	; 0x134 <VOICES_SEL>
#endif
		break;
 3fa:	08 95       	ret
	case 2:				//長ｵﾝ一致のとき
	
//ﾓｰﾀｰ停止;　24/05/23 追加 YM
#ifdef MTR_BIT				//ﾓｰﾀｰ制御ﾎﾟｰﾄが実装されているとき
MTR_PORT.OUTCLR=1<<MTR_BIT;		//ﾓｰﾀｰを停止（論理反転 YM)
 3fc:	80 e4       	ldi	r24, 0x40	; 64
 3fe:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__RODATA_PM_OFFSET__+0x7f8406>
#endif
#if VOICE_C>0				//音声C再生を実装するとき
		VOICEC_SEL(0);			//再生中断する
#endif
#if VOICE_S>0				//音声S再生を実装するとき
		VOICES_SEL(0);			//再生中断する
 402:	80 e0       	ldi	r24, 0x00	; 0
 404:	90 e0       	ldi	r25, 0x00	; 0
 406:	96 de       	rcall	.-724    	; 0x134 <VOICES_SEL>
 408:	08 95       	ret

Disassembly of section .text.main:

0000008a <main>:
{
#if VOICE_C>0					//SDを使うとき
	unsigned char n;
#endif

	wait_ms(10);				//電圧安定時間
  8a:	8a e0       	ldi	r24, 0x0A	; 10
  8c:	90 e0       	ldi	r25, 0x00	; 0
  8e:	af d2       	rcall	.+1374   	; 0x5ee <wait_ms>
	CB_INIT();				//ﾃﾞﾊﾞｲｽの初期設定
  90:	a5 d0       	rcall	.+330    	; 0x1dc <CB_INIT>
//==============================================
//固有処理
//==============================================
//DBG_C('k');
//DBG_S(kyotuu.ps);
		if(!(kyotuu.ps--))		//固有処理のﾀｲﾐﾝｸﾞになったら
  92:	e6 e3       	ldi	r30, 0x36	; 54
  94:	ff e3       	ldi	r31, 0x3F	; 63
  96:	80 81       	ld	r24, Z
  98:	91 81       	ldd	r25, Z+1	; 0x01
  9a:	9c 01       	movw	r18, r24
  9c:	21 50       	subi	r18, 0x01	; 1
  9e:	31 09       	sbc	r19, r1
  a0:	20 83       	st	Z, r18
  a2:	31 83       	std	Z+1, r19	; 0x01
  a4:	89 2b       	or	r24, r25
  a6:	39 f4       	brne	.+14     	; 0xb6 <main+0x2c>
		{
			kyotuu.ps=(unsigned long)KOYUU_PR*1000/PWM_PR-1;
  a8:	87 e0       	ldi	r24, 0x07	; 7
  aa:	94 e0       	ldi	r25, 0x04	; 4
  ac:	80 93 36 3f 	sts	0x3F36, r24	; 0x803f36 <kyotuu>
  b0:	90 93 37 3f 	sts	0x3F37, r25	; 0x803f37 <kyotuu+0x1>
						//固有処理ﾌﾟﾘｽｹｰﾗを初期化
			CB_KOYUU();		//固有処理(ｺｰﾙﾊﾞｯｸ関数)を呼出す
  b4:	71 d1       	rcall	.+738    	; 0x398 <CB_KOYUU>


//==============================================
//出力事前処理
//==============================================
		kyotuu.pcm=0;			//PCM合算値をｸﾘｱしておく
  b6:	10 92 38 3f 	sts	0x3F38, r1	; 0x803f38 <kyotuu+0x2>
  ba:	10 92 39 3f 	sts	0x3F39, r1	; 0x803f39 <kyotuu+0x3>
#if VOICE_S>0
//==============================================
//音声S再生処理
//==============================================
//DBG_C('s');
		if(voiceS.no)			//再生中のとき
  be:	80 91 30 3f 	lds	r24, 0x3F30	; 0x803f30 <voiceS+0x8>
  c2:	90 91 31 3f 	lds	r25, 0x3F31	; 0x803f31 <voiceS+0x9>
  c6:	89 2b       	or	r24, r25
  c8:	c1 f0       	breq	.+48     	; 0xfa <main+0x70>
		{
			if(!(voiceS.ps--))	//再生処理のﾀｲﾐﾝｸﾞになったら
  ca:	e8 e2       	ldi	r30, 0x28	; 40
  cc:	ff e3       	ldi	r31, 0x3F	; 63
  ce:	85 85       	ldd	r24, Z+13	; 0x0d
  d0:	9f ef       	ldi	r25, 0xFF	; 255
  d2:	98 0f       	add	r25, r24
  d4:	95 87       	std	Z+13, r25	; 0x0d
  d6:	81 11       	cpse	r24, r1
  d8:	04 c0       	rjmp	.+8      	; 0xe2 <main+0x58>
			{
				voiceS.ps=voiceS.psn-1;
  da:	84 85       	ldd	r24, Z+12	; 0x0c
  dc:	81 50       	subi	r24, 0x01	; 1
  de:	85 87       	std	Z+13, r24	; 0x0d
						//演奏処理ﾌﾟﾘｽｹｰﾗを初期化
				voiceS_exe();	//演奏処理を実行する
  e0:	1c d1       	rcall	.+568    	; 0x31a <voiceS_exe>
			}
			kyotuu.pcm+=voiceS.pcm;	//PCM値を反映する
  e2:	80 91 32 3f 	lds	r24, 0x3F32	; 0x803f32 <voiceS+0xa>
  e6:	90 91 33 3f 	lds	r25, 0x3F33	; 0x803f33 <voiceS+0xb>
  ea:	e6 e3       	ldi	r30, 0x36	; 54
  ec:	ff e3       	ldi	r31, 0x3F	; 63
  ee:	22 81       	ldd	r18, Z+2	; 0x02
  f0:	33 81       	ldd	r19, Z+3	; 0x03
  f2:	82 0f       	add	r24, r18
  f4:	93 1f       	adc	r25, r19
  f6:	82 83       	std	Z+2, r24	; 0x02
  f8:	93 83       	std	Z+3, r25	; 0x03
//==============================================
//ﾊﾞｯﾌｧ書出し
//==============================================
//DBG_C('b');
//DBG_S(kyotuu.pcm);
		if(kyotuu.pcm>=(PWM_STEP+1)/2) kyotuu.pcm=(PWM_STEP+1)/2-1;
  fa:	80 91 38 3f 	lds	r24, 0x3F38	; 0x803f38 <kyotuu+0x2>
  fe:	90 91 39 3f 	lds	r25, 0x3F39	; 0x803f39 <kyotuu+0x3>
 102:	88 3f       	cpi	r24, 0xF8	; 248
 104:	91 05       	cpc	r25, r1
 106:	3c f0       	brlt	.+14     	; 0x116 <__DATA_REGION_LENGTH__+0x16>
 108:	87 ef       	ldi	r24, 0xF7	; 247
 10a:	90 e0       	ldi	r25, 0x00	; 0
 10c:	80 93 38 3f 	sts	0x3F38, r24	; 0x803f38 <kyotuu+0x2>
 110:	90 93 39 3f 	sts	0x3F39, r25	; 0x803f39 <kyotuu+0x3>
 114:	09 c0       	rjmp	.+18     	; 0x128 <__DATA_REGION_LENGTH__+0x28>
						//有効な範囲に規制する
		else if(kyotuu.pcm<=-PWM_STEP/2) kyotuu.pcm=-PWM_STEP/2+1;
 116:	89 30       	cpi	r24, 0x09	; 9
 118:	9f 4f       	sbci	r25, 0xFF	; 255
 11a:	34 f4       	brge	.+12     	; 0x128 <__DATA_REGION_LENGTH__+0x28>
 11c:	89 e0       	ldi	r24, 0x09	; 9
 11e:	9f ef       	ldi	r25, 0xFF	; 255
 120:	80 93 38 3f 	sts	0x3F38, r24	; 0x803f38 <kyotuu+0x2>
 124:	90 93 39 3f 	sts	0x3F39, r25	; 0x803f39 <kyotuu+0x3>
		put_buf(kyotuu.pcm);		//PCM形式でﾊﾞｯﾌｧに出力する
 128:	80 91 38 3f 	lds	r24, 0x3F38	; 0x803f38 <kyotuu+0x2>
 12c:	90 91 39 3f 	lds	r25, 0x3F39	; 0x803f39 <kyotuu+0x3>
 130:	ef d1       	rcall	.+990    	; 0x510 <put_buf>
	}
 132:	af cf       	rjmp	.-162    	; 0x92 <main+0x8>

Disassembly of section .text.__vector_7:

000005b2 <__vector_7>:

//==============================================
//PIT割込みﾊﾝﾄﾞﾗ
//==============================================
ISR(RTC_PIT_vect)
{
 5b2:	1f 92       	push	r1
 5b4:	0f 92       	push	r0
 5b6:	0f b6       	in	r0, 0x3f	; 63
 5b8:	0f 92       	push	r0
 5ba:	11 24       	eor	r1, r1
 5bc:	8f 93       	push	r24

	RTC.PITINTFLAGS=RTC_PI_bm;		//PIT割込みﾌﾗｸﾞをｸﾘｱ
 5be:	81 e0       	ldi	r24, 0x01	; 1
 5c0:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <__RODATA_PM_OFFSET__+0x7f8153>
}
 5c4:	8f 91       	pop	r24
 5c6:	0f 90       	pop	r0
 5c8:	0f be       	out	0x3f, r0	; 63
 5ca:	0f 90       	pop	r0
 5cc:	1f 90       	pop	r1
 5ce:	18 95       	reti

Disassembly of section .text.__vector_3:

000005d0 <__vector_3>:

//==============================================
//ﾋﾟﾝ変化割込みﾊﾝﾄﾞﾗ
//==============================================
ISR(PORTA_PORT_vect)
{
 5d0:	1f 92       	push	r1
 5d2:	0f 92       	push	r0
 5d4:	0f b6       	in	r0, 0x3f	; 63
 5d6:	0f 92       	push	r0
 5d8:	11 24       	eor	r1, r1
 5da:	8f 93       	push	r24
	PORTA.INTFLAGS=0xff;			//ﾋﾟﾝ変化割込みﾌﾗｸﾞをｸﾘｱする
 5dc:	8f ef       	ldi	r24, 0xFF	; 255
 5de:	80 93 09 04 	sts	0x0409, r24	; 0x800409 <__RODATA_PM_OFFSET__+0x7f8409>
}
 5e2:	8f 91       	pop	r24
 5e4:	0f 90       	pop	r0
 5e6:	0f be       	out	0x3f, r0	; 63
 5e8:	0f 90       	pop	r0
 5ea:	1f 90       	pop	r1
 5ec:	18 95       	reti

Disassembly of section .text.libgcc.mul:

0000069e <__usmulhisi3>:
 69e:	dc df       	rcall	.-72     	; 0x658 <__umulhisi3>

000006a0 <__usmulhisi3_tail>:
 6a0:	b7 ff       	sbrs	r27, 7
 6a2:	08 95       	ret
 6a4:	82 1b       	sub	r24, r18
 6a6:	93 0b       	sbc	r25, r19
 6a8:	08 95       	ret

Disassembly of section .text.libgcc.mul:

00000658 <__umulhisi3>:
 658:	a2 9f       	mul	r26, r18
 65a:	b0 01       	movw	r22, r0
 65c:	b3 9f       	mul	r27, r19
 65e:	c0 01       	movw	r24, r0
 660:	a3 9f       	mul	r26, r19
 662:	01 d0       	rcall	.+2      	; 0x666 <__umulhisi3+0xe>
 664:	b2 9f       	mul	r27, r18
 666:	70 0d       	add	r23, r0
 668:	81 1d       	adc	r24, r1
 66a:	11 24       	eor	r1, r1
 66c:	91 1d       	adc	r25, r1
 66e:	08 95       	ret

Disassembly of section .text.__dummy_fini:

000006d0 <_fini>:
 6d0:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

000006d2 <__funcs_on_exit>:
 6d2:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

000006d4 <__simulator_exit>:
 6d4:	08 95       	ret

Disassembly of section .text.exit:

00000690 <exit>:
 690:	ec 01       	movw	r28, r24
 692:	1f d0       	rcall	.+62     	; 0x6d2 <__funcs_on_exit>
 694:	1d d0       	rcall	.+58     	; 0x6d0 <_fini>
 696:	ce 01       	movw	r24, r28
 698:	1d d0       	rcall	.+58     	; 0x6d4 <__simulator_exit>
 69a:	ce 01       	movw	r24, r28
 69c:	1c d0       	rcall	.+56     	; 0x6d6 <_Exit>

Disassembly of section .text._Exit:

000006d6 <_Exit>:
 6d6:	d7 dc       	rcall	.-1618   	; 0x86 <_exit>

Disassembly of section .text.avrlibc:

000006aa <ccp_write_io>:
 6aa:	dc 01       	movw	r26, r24
 6ac:	28 ed       	ldi	r18, 0xD8	; 216
 6ae:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__RODATA_PM_OFFSET__+0x7f8034>
 6b2:	6c 93       	st	X, r22
 6b4:	08 95       	ret
